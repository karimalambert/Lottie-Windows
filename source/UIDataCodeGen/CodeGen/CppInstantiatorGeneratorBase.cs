// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Numerics;
using Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData;
using Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData.MetaData;
using Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData.Mgcg;
using Microsoft.Toolkit.Uwp.UI.Lottie.WinUIXamlMediaData;
using Newtonsoft.Json.Serialization;
using Mgce = Microsoft.Toolkit.Uwp.UI.Lottie.WinCompData.Mgce;

namespace Microsoft.Toolkit.Uwp.UI.Lottie.UIData.CodeGen
{
#if PUBLIC_UIDataCodeGen
    public
#endif
    class CppInstantiatorGeneratorBase : InstantiatorGeneratorBase
    {
        const string Muxc = "Microsoft::UI::Xaml::Controls";
        const string Wuc = "Windows::UI::Composition";
        readonly bool _isCppWinrtMode;
        readonly CppStringifier _s;
        readonly string _headerFileName;
        readonly TypeNames _typeName;

        private protected CppInstantiatorGeneratorBase(
            CodegenConfiguration configuration,
            bool setCommentProperties,
            CppStringifier stringifier,
            string headerFileName,
            bool isCppwinrtMode)
            : base(
                  configuration: configuration,
                  setCommentProperties: setCommentProperties,
                  stringifier: stringifier)
        {
            _s = stringifier;
            _isCppWinrtMode = isCppwinrtMode;
            _headerFileName = headerFileName;
            _typeName = new TypeNames(stringifier, isCppwinrtMode);
        }

        // Generates the .h file contents.
        protected string GenerateHeaderText(IAnimatedVisualSourceInfo info)
        {
            // Returns the header text that implements IAnimatedVisualSource if loadedImageSurfacesNodes is null or empty.
            // Otherwise, return the header text that implements IDynamicAnimatedVisualSource.
            var builder = new CodeBuilder();

            builder.WriteLine("#pragma once");
            builder.WriteLine(string.Join("\r\n", AutoGeneratedHeaderText));

            if (info.LoadedImageSurfaces.Any())
            {
                WriteIDynamicAnimatedVisualSourceHeaderText(builder, info);
            }
            else
            {
                WriteIAnimatedVisualSourceHeaderText(builder, info);
            }

            return builder.ToString();
        }

        /// <inheritdoc/>
        // Called by the base class to write the start of the file (i.e. everything up to the body of the Instantiator class).
        protected override void WriteFileStart(
            CodeBuilder builder,
            IAnimatedVisualSourceInfo info)
        {
            builder.WriteLine("#include \"pch.h\"");
            builder.WriteLine($"#include \"{_headerFileName}\"");

            // floatY, floatYxZ
            builder.WriteLine("#include \"WindowsNumerics.h\"");

            if (info.UsesCanvas ||
                info.UsesCanvasEffects ||
                info.UsesCanvasGeometry)
            {
                // D2D
                builder.WriteLine("#include \"d2d1.h\"");
                builder.WriteLine("#include <d2d1_1.h>");
                builder.WriteLine("#include <d2d1helper.h>");

                // Interop
                // BUILD_WINDOWS is defined if the code is being built as part of a Microsoft internal
                // Windows build. In that case the types in the Windows.Graphics.Effects.Interop.h file will
                // be in the Windows::Graphics::Effects namespace.
                //
                // Otherwise, the code is being built normally and the types will be in the
                // ABI::Windows::Graphics::Effects namespace.
                //
                // To work around this inconsistency, when BUILD_WINDOWS is defined, we wrap the include
                // of Windows.Grapics.Interop.h in the ABI namespace so that the types in that file
                // will always be in the ABI::Windows::Graphics::Effects namespace. And in our
                // generated code we always refer to the types in that file using the ABI:: prefix.
                builder.WriteLine("#ifdef BUILD_WINDOWS");
                builder.WriteLine("namespace ABI");
                builder.WriteLine("{");
                builder.WriteLine("#include <Windows.Graphics.Effects.Interop.h>");
                builder.WriteLine("#include <Windows.Graphics.Interop.h>");
                builder.WriteLine("}");
                builder.WriteLine("#else");
                builder.WriteLine("#include <Windows.Graphics.Effects.Interop.h>");
                builder.WriteLine("#include <Windows.Graphics.Interop.h>");
                builder.WriteLine("#endif");

                // ComPtr
                builder.WriteLine("#include <wrl.h>");
            }

            if (info.UsesStreams)
            {
                builder.WriteLine("#include <iostream>");
            }

            if (info.UsesCompositeEffect)
            {
                // The CompsiteEffect class requires std::vector.
                builder.WriteLine("#include <vector>");
            }

            if (info.UsesCanvasEffects ||
                info.UsesCanvas)
            {
                // Interop
                builder.WriteLine("#include <Windows.Graphics.Interop.h>");
                builder.WriteLine("#include <Windows.Graphics.Effects.h>");
            }

            builder.WriteLine();

            // A sorted set to hold the namespaces that the generated code will use. The set is maintained in sorted order.
            var namespaces = new SortedSet<string>();

            namespaces.Add(Muxc);
            if (!_isCppWinrtMode)
            {
                namespaces.Add("Platform");
            }

            namespaces.Add("Windows::Foundation");
            namespaces.Add("Windows::Foundation::Metadata");
            namespaces.Add("Windows::Foundation::Numerics");
            namespaces.Add("Windows::UI");
            namespaces.Add(Wuc);
            namespaces.Add("Windows::Graphics");

            if (info.UsesCanvas ||
                info.UsesCanvasEffects ||
                info.UsesCanvasGeometry)
            {
                namespaces.Add("Microsoft::WRL");
            }

            if (info.UsesNamespaceWindowsUIXamlMedia)
            {
                namespaces.Add("Windows::UI::Xaml::Media");
            }

            if (info.UsesStreams)
            {
                namespaces.Add("Platform");
                namespaces.Add("Windows::Storage::Streams");
            }

            // Write out each namespace using.
            foreach (var n in namespaces)
            {
                if (_isCppWinrtMode)
                {
                    builder.WriteLine($"using namespace winrt::{n};");
                }
                else
                {
                    builder.WriteLine($"using namespace {n};");
                }
            }

            builder.WriteLine();

            // Put the Instantiator class in an anonymous namespace.
            builder.WriteLine("namespace");
            builder.WriteLine("{");
            builder.Indent();

            if (info.IsThemed)
            {
                if (info.SourceMetadata.PropertyBindings.Any(pb => pb.exposedType == PropertySetValueType.Color))
                {
                    // There's at least one themed color. It will need a helper method to convert to Vector4.
                    builder.WriteLine("float4 ColorAsVector4(Color color)");
                    builder.OpenScope();
                    builder.WriteLine("return { static_cast<float>(color.R), static_cast<float>(color.G), static_cast<float>(color.B), static_cast<float>(color.A) };");
                    builder.CloseScope();
                    builder.WriteLine();
                }
            }

            if (info.UsesCanvasEffects ||
                info.UsesCanvasGeometry)
            {
                // Write GeoSource to allow it's use in function definitions
                builder.WriteLine($"{_s.GeoSourceClass}");

                // Typedef to simplify generation
                builder.WriteLine("typedef ComPtr<GeoSource> CanvasGeometry;");
                builder.WriteLine();
            }

            if (info.UsesCompositeEffect)
            {
                // Write the composite effect class that will allow the use
                // of this effect without win2d.
                builder.WriteLine($"{CompositionEffectClass}");
            }
        }

        /// <inheritdoc/>
        protected override void WriteAnimatedVisualStart(
            CodeBuilder builder,
            IAnimatedVisualInfo info)
        {
            // Start writing the instantiator.
            if (_isCppWinrtMode)
            {
                builder.WriteLine($"class {info.ClassName}");
                builder.Indent();
                builder.WriteLine($": public winrt::implements<{info.ClassName}, winrt::IAnimatedVisual, winrt::IClosable>");
                builder.UnIndent();
            }
            else
            {
                builder.WriteLine($"ref class {info.ClassName} sealed");
                builder.Indent();
                builder.WriteLine($": public IAnimatedVisual");
                builder.UnIndent();
            }

            builder.OpenScope();

            if (info.AnimatedVisualSourceInfo.UsesCanvasEffects ||
                info.AnimatedVisualSourceInfo.UsesCanvasGeometry)
            {
                // D2D factory field.
                builder.WriteLine("ComPtr<ID2D1Factory> _d2dFactory;");
            }
        }

        IEnumerable<string> GetConstructorParameters(IAnimatedVisualInfo info)
        {
            yield return $"{_typeName.Compositor} compositor";

            if (info.AnimatedVisualSourceInfo.IsThemed)
            {
                yield return $"{_typeName.CompositionPropertySet} themeProperties";
            }

            foreach (var loadedImageSurfaceNode in info.LoadedImageSurfaceNodes)
            {
                yield return $"{_s.ReferenceTypeName(loadedImageSurfaceNode.TypeName)} {_s.CamelCase(loadedImageSurfaceNode.Name)}";
            }
        }

        /// <inheritdoc/>
        // Called by the base class to write the end of the AnimatedVisual class.
        protected override void WriteAnimatedVisualEnd(
            CodeBuilder builder,
            IAnimatedVisualInfo info)
        {
            if (info.AnimatedVisualSourceInfo.UsesCanvasEffects ||
                info.AnimatedVisualSourceInfo.UsesCanvasGeometry)
            {
                // Utility method for D2D geometries
                builder.WriteLine($"static {_s.ReferenceTypeName(_typeName.IGeometrySource2D)} CanvasGeometryToIGeometrySource2D(CanvasGeometry geo)");
                builder.OpenScope();
                builder.WriteLine($"ComPtr<ABI::Windows::Graphics::{_typeName.IGeometrySource2D}> interop = geo.Detach();");
                builder.WriteLine($"return reinterpret_cast<{_s.ReferenceTypeName(_typeName.IGeometrySource2D)}>(interop.Get());");
                builder.CloseScope();
                builder.WriteLine();

                // Utility method for fail-fasting on bad HRESULTs from d2d operations
                builder.WriteLine("static void FFHR(HRESULT hr)");
                builder.OpenScope();
                builder.WriteLine("if (hr != S_OK)");
                builder.OpenScope();
                builder.WriteLine("RoFailFastWithErrorContext(hr);");
                builder.CloseScope();
                builder.CloseScope();
                builder.WriteLine();
            }

            // Write the constructor for the AnimatedVisual class.
            builder.UnIndent();
            builder.WriteLine("public:");
            builder.Indent();

            // Constructor
            builder.WriteBreakableLine($"{info.ClassName}(", CommaSeparate(GetConstructorParameters(info)), ")");
            builder.Indent();

            // Initializer list.
            builder.WriteLine(": _c(compositor)");
            if (info.AnimatedVisualSourceInfo.IsThemed)
            {
                builder.WriteLine($", {info.AnimatedVisualSourceInfo.ThemePropertiesFieldName}(themeProperties)");
            }

            // Initialize the image surfaces.
            foreach (var n in info.LoadedImageSurfaceNodes)
            {
                builder.WriteLine($", {n.FieldName}({_s.CamelCase(n.Name)})");
            }

            // Instantiate the reusable ExpressionAnimation.
            builder.WriteLine($", {info.AnimatedVisualSourceInfo.ReusableExpressionAnimationFieldName}(compositor{_s.Deref}CreateExpressionAnimation())");

            builder.UnIndent();

            builder.OpenScope();
            if (info.AnimatedVisualSourceInfo.UsesCanvasEffects ||
                info.AnimatedVisualSourceInfo.UsesCanvasGeometry)
            {
                builder.WriteLine($"{FailFastWrapper("D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, _d2dFactory.GetAddressOf())")};");
            }

            // Instantiate the root. This will cause the whole Visual tree to be built and animations started.
            builder.WriteLine("const auto _ = Root();");
            builder.CloseScope();

            // Write the destructor. This is how CX implements IClosable/IDisposable.
            builder.WriteLine();
            if (_isCppWinrtMode)
            {
                builder.WriteLine("void Close()");
                builder.OpenScope();
                builder.WriteLine("if (_root)");
                builder.OpenScope();
                builder.WriteLine("_root.Close();");
                builder.CloseScope();
                builder.CloseScope();
            }
            else
            {
                // CX doesn't need to do anything - the root object will be disposed
                // as a result of this object being cleaned up.
                builder.WriteLine($"virtual ~{info.ClassName}() {{ }}");
            }

            // Write the members on IAnimatedVisual.
            builder.WriteLine();
            {
                var propertyImplBuilder = new CodeBuilder();
                propertyImplBuilder.WriteLine($"return {{ {_s.TimeSpan(info.AnimatedVisualSourceInfo.DurationTicksFieldName)} }};");
                WritePropertyImpl(builder, isVirtual: true, "TimeSpan", "Duration", propertyImplBuilder);
            }

            builder.WriteLine();
            {
                var propertyImplBuilder = new CodeBuilder();
                propertyImplBuilder.WriteLine("return _root;");
                WritePropertyImpl(builder, isVirtual: true, _typeName.Visual, "RootVisual", propertyImplBuilder);
            }

            builder.WriteLine();
            {
                var propertyImplBuilder = new CodeBuilder();
                propertyImplBuilder.WriteLine($"return {Vector2(info.AnimatedVisualSourceInfo.CompositionDeclaredSize)};");
                WritePropertyImpl(builder, isVirtual: true, "float2", "Size", propertyImplBuilder);
            }

            // Write the IsRuntimeCompatible static method.
            builder.WriteLine("static bool IsRuntimeCompatible()");
            builder.OpenScope();
            builder.WriteLine($"return ApiInformation::IsApiContractPresent({_s.String("Windows.Foundation.UniversalApiContract")}, {info.RequiredUapVersion});");
            builder.CloseScope();

            // Close the scope for the instantiator class.
            builder.CloseCppTypeScope();
        }

        void WritePropertyImpl(
            CodeBuilder builder,
            bool isVirtual,
            string returnType,
            string propertyName,
            CodeBuilder getImplementation)
        {
            if (_isCppWinrtMode)
            {
                builder.WriteLine($"{returnType} {propertyName}() const");
                builder.OpenScope();
                builder.WriteCodeBuilder(getImplementation);
                builder.CloseScope();
                builder.WriteLine();
            }
            else
            {
                builder.WriteLine($"property {returnType} {propertyName}");
                builder.OpenScope();
                builder.WriteLine($"{(isVirtual ? "virtual " : string.Empty)}{returnType} get()");
                builder.OpenScope();
                builder.WriteCodeBuilder(getImplementation);
                builder.CloseScope();
                builder.CloseScope();
                builder.WriteLine();
            }
        }

        /// <inheritdoc/>
        // Called by the base class to write the end of the file (i.e. everything after the body of the AnimatedVisual class).
        protected override void WriteFileEnd(
            CodeBuilder builder,
            IAnimatedVisualSourceInfo info)
        {
            // Close the anonymous namespace.
            builder.UnIndent();
            builder.WriteLine("} // end namespace");
            builder.WriteLine();

            // Generate the methods that create and get the theme property set.
            if (info.IsThemed)
            {
                builder.WriteLine($"{_typeName.CompositionPropertySet} {_s.Namespace(info.Namespace)}::{info.ClassName}::EnsureThemeProperties({_typeName.Compositor} compositor)");
                builder.OpenScope();
                builder.WriteLine($"if ({info.ThemePropertiesFieldName} == nullptr)");
                builder.OpenScope();
                builder.WriteLine($"{info.ThemePropertiesFieldName} = compositor{_s.Deref}CreatePropertySet();");

                // Initialize the values in the property set.
                foreach (var prop in info.SourceMetadata.PropertyBindings)
                {
                    WriteThemePropertyInitialization(
                        builder,
                        info.ThemePropertiesFieldName,
                        prop.bindingName,
                        prop.exposedType,
                        prop.actualType);
                }

                builder.CloseScope();
                builder.WriteLine();
                builder.WriteLine($"return {info.ThemePropertiesFieldName};");
                builder.CloseScope();
                builder.WriteLine();

                builder.WriteLine($"{_typeName.CompositionPropertySet} {_s.Namespace(info.Namespace)}::{info.ClassName}::GetThemeProperties({_typeName.Compositor} compositor)");
                builder.OpenScope();
                builder.WriteLine("return EnsureThemeProperties(compositor);");
                builder.CloseScope();
                builder.WriteLine();

                // Write property implementations for each theme property.
                foreach (var prop in info.SourceMetadata.PropertyBindings)
                {
                    // Write the getter. This just reads the values out of the backing field.
                    if (_isCppWinrtMode)
                    {
                        builder.WriteLine($"{TypeName(prop.exposedType)} {info.Namespace}::{info.ClassName}::{prop.bindingName}()");
                        builder.OpenScope();
                        builder.WriteLine($"return _theme{prop.bindingName};");
                        builder.CloseScope();
                        builder.WriteLine();
                    }
                    else
                    {
                        builder.WriteLine($"{TypeName(prop.exposedType)} {info.Namespace}::{info.ClassName}::{prop.bindingName}::get()");
                        builder.OpenScope();
                        builder.WriteLine($"return _theme{prop.bindingName};");
                        builder.CloseScope();
                        builder.WriteLine();
                    }

                    // Write the setter. This saves to the backing field, and updates the theme property
                    // set if one has been created.
                    if (_isCppWinrtMode)
                    {
                        builder.WriteLine($"void {info.Namespace}::{info.ClassName}::{prop.bindingName}({TypeName(prop.exposedType)} value)");
                        builder.OpenScope();
                        builder.WriteLine($"_theme{prop.bindingName} = value;");
                        builder.WriteLine("if (_themeProperties != nullptr)");
                        builder.OpenScope();
                        WriteThemePropertyInitialization(builder, "_themeProperties", prop.bindingName, prop.exposedType, prop.actualType);
                        builder.CloseScope();
                        builder.CloseScope();
                        builder.WriteLine();
                    }
                    else
                    {
                        builder.WriteLine($"void {info.Namespace}::{info.ClassName}::{prop.bindingName}::set({TypeName(prop.exposedType)} value)");
                        builder.OpenScope();
                        builder.WriteLine($"_theme{prop.bindingName} = value;");
                        builder.WriteLine("if (_themeProperties != nullptr)");
                        builder.OpenScope();
                        WriteThemePropertyInitialization(builder, "_themeProperties", prop.bindingName, prop.exposedType, prop.actualType);
                        builder.CloseScope();
                        builder.CloseScope();
                        builder.WriteLine();
                    }
                }
            }

            // Generate the method that creates an instance of the composition on the IAnimatedVisualSource
            builder.WriteLine($"{_typeName.IAnimatedVisual} {_s.Namespace(info.Namespace)}::{info.ClassName}::TryCreateAnimatedVisual(");
            builder.Indent();
            if (_isCppWinrtMode)
            {
                builder.WriteLine($"const {_typeName.Compositor}& compositor,");
                builder.WriteLine($"{_typeName.Object}& diagnostics)");
            }
            else
            {
                builder.WriteLine($"{_typeName.Compositor} compositor,");
                builder.WriteLine($"{_typeName.Object}* diagnostics)");
            }

            builder.UnIndent();
            builder.OpenScope();

            if (info.IsThemed)
            {
                builder.WriteLine("const auto _ = EnsureThemeProperties(compositor);");
            }

            if (info.LoadedImageSurfaces.Count > 0)
            {
                WriteIDynamicAnimatedVisualSource(builder, info);
            }
            else
            {
                WriteIAnimatedVisualSource(builder, info);
            }
        }

        /// <inheritdoc/>
        protected override void WriteCanvasGeometryCombinationFactory(CodeBuilder builder, CanvasGeometry.Combination obj, string typeName, string fieldName)
        {
            builder.WriteLine($"{typeName} result;");
            builder.WriteLine("ID2D1Geometry *geoA = nullptr, *geoB = nullptr;");
            builder.WriteLine($"{CallFactoryFor(obj.A)}->GetGeometry(&geoA);");
            builder.WriteLine($"{CallFactoryFor(obj.B)}->GetGeometry(&geoB);");
            builder.WriteLine("ComPtr<ID2D1PathGeometry> path;");
            builder.WriteLine($"{FailFastWrapper("_d2dFactory->CreatePathGeometry(&path)")};");
            builder.WriteLine("ComPtr<ID2D1GeometrySink> sink;");
            builder.WriteLine($"{FailFastWrapper("path->Open(&sink)")};");
            builder.WriteLine($"FFHR(geoA->CombineWithGeometry(");
            builder.Indent();
            builder.WriteLine($"geoB,");
            builder.WriteLine($"{_s.CanvasGeometryCombine(obj.CombineMode)},");
            builder.WriteLine($"{_s.Matrix3x2(obj.Matrix)},");
            builder.WriteLine($"sink.Get()));");
            builder.UnIndent();
            builder.WriteLine("geoA->Release();");
            builder.WriteLine("geoB->Release();");
            builder.WriteLine($"{FailFastWrapper("sink->Close()")};");
            builder.WriteLine($"result = {FieldAssignment(fieldName)}new GeoSource(path.Get());");
        }

        /// <inheritdoc/>
        protected override void WriteCanvasGeometryEllipseFactory(CodeBuilder builder, CanvasGeometry.Ellipse obj, string typeName, string fieldName)
        {
            builder.WriteLine($"{typeName} result;");
            builder.WriteLine("ComPtr<ID2D1EllipseGeometry> ellipse;");
            builder.WriteLine("FFHR(_d2dFactory->CreateEllipseGeometry(");
            builder.Indent();
            builder.WriteLine($"D2D1::Ellipse({{{Float(obj.X)},{Float(obj.Y)}}}, {Float(obj.RadiusX)}, {Float(obj.RadiusY)}),");
            builder.WriteLine("&ellipse));");
            builder.UnIndent();
            builder.WriteLine($"result = {FieldAssignment(fieldName)}new GeoSource(ellipse.Get());");
        }

        /// <inheritdoc/>
        protected override void WriteCanvasGeometryGroupFactory(CodeBuilder builder, CanvasGeometry.Group obj, string typeName, string fieldName)
        {
            builder.WriteLine($"ComPtr<ID2D1Geometry> geometries[{obj.Geometries.Length}];");
            builder.OpenScope();
            for (var i = 0; i < obj.Geometries.Length; i++)
            {
                var geometry = obj.Geometries[i];
                builder.WriteLine($"{CallFactoryFor(geometry)}.Get()->GetGeometry(&geometries[{i}]);");
            }

            builder.CloseScope();
            builder.WriteLine($"{typeName} result;");
            builder.WriteLine("ComPtr<ID2D1GeometryGroup> group;");
            builder.WriteLine("FFHR(_d2dFactory->CreateGeometryGroup(");
            builder.Indent();
            builder.WriteLine($"{FilledRegionDetermination(obj.FilledRegionDetermination)},");
            builder.WriteLine("geometries[0].GetAddressOf(),");
            builder.WriteLine($"{obj.Geometries.Length},");
            builder.WriteLine("&group));");
            builder.UnIndent();
            builder.WriteLine($"result = {FieldAssignment(fieldName)}new GeoSource(group.Get());");
        }

        /// <inheritdoc/>
        protected override void WriteCanvasGeometryPathFactory(CodeBuilder builder, CanvasGeometry.Path obj, string typeName, string fieldName)
        {
            builder.WriteLine($"{typeName} result;");

            // D2D Setup
            builder.WriteLine("ComPtr<ID2D1PathGeometry> path;");
            builder.WriteLine($"{FailFastWrapper("_d2dFactory->CreatePathGeometry(&path)")};");
            builder.WriteLine("ComPtr<ID2D1GeometrySink> sink;");
            builder.WriteLine($"{FailFastWrapper("path->Open(&sink)")};");

            if (obj.FilledRegionDetermination != CanvasFilledRegionDetermination.Alternate)
            {
                builder.WriteLine($"sink->SetFillMode({FilledRegionDetermination(obj.FilledRegionDetermination)});");
            }

            foreach (var command in obj.Commands)
            {
                switch (command.Type)
                {
                    case CanvasPathBuilder.CommandType.BeginFigure:
                        // Assume D2D1_FIGURE_BEGIN_FILLED
                        builder.WriteLine($"sink->BeginFigure({Vector2(((CanvasPathBuilder.Command.BeginFigure)command).StartPoint)}, D2D1_FIGURE_BEGIN_FILLED);");
                        break;
                    case CanvasPathBuilder.CommandType.EndFigure:
                        builder.WriteLine($"sink->EndFigure({CanvasFigureLoop(((CanvasPathBuilder.Command.EndFigure)command).FigureLoop)});");
                        break;
                    case CanvasPathBuilder.CommandType.AddLine:
                        builder.WriteLine($"sink->AddLine({Vector2(((CanvasPathBuilder.Command.AddLine)command).EndPoint)});");
                        break;
                    case CanvasPathBuilder.CommandType.AddCubicBezier:
                        var cb = (CanvasPathBuilder.Command.AddCubicBezier)command;
                        builder.WriteLine($"sink->AddBezier({{ {Vector2(cb.ControlPoint1)}, {Vector2(cb.ControlPoint2)}, {Vector2(cb.EndPoint)} }});");
                        break;
                    default:
                        throw new InvalidOperationException();
                }
            }

            builder.WriteLine($"{FailFastWrapper("sink->Close()")};");
            builder.WriteLine("GeoSource* rawResult = new GeoSource(path.Get());");
            builder.WriteLine($"result = {FieldAssignment(fieldName)}rawResult;");
            builder.WriteLine("rawResult->Release();");
        }

        /// <inheritdoc/>
        protected override void WriteCanvasGeometryRoundedRectangleFactory(CodeBuilder builder, CanvasGeometry.RoundedRectangle obj, string typeName, string fieldName)
        {
            builder.WriteLine($"{typeName} result;");
            builder.WriteLine("ComPtr<ID2D1RoundedRectangleGeometry> rect;");
            builder.WriteLine("FFHR(_d2dFactory->CreateRoundedRectangleGeometry(");
            builder.Indent();
            builder.WriteLine($"D2D1::RoundedRect({{{Float(obj.X)},{Float(obj.Y)}}}, {Float(obj.RadiusX)}, {Float(obj.RadiusY)}),");
            builder.WriteLine("&rect));");
            builder.UnIndent();
            builder.WriteLine($"result = {FieldAssignment(fieldName)}new GeoSource(rect.Get());");
        }

        /// <inheritdoc/>
        protected override void WriteCanvasGeometryTransformedGeometryFactory(CodeBuilder builder, CanvasGeometry.TransformedGeometry obj, string typeName, string fieldName)
        {
            builder.WriteLine($"{typeName} result;");
            builder.WriteLine("ID2D1Geometry *geoA = nullptr;");
            builder.WriteLine("ID2D1TransformedGeometry *transformed;");
            builder.WriteLine($"D2D1_MATRIX_3X2_F transformMatrix{_s.Matrix3x2(obj.TransformMatrix)};");
            builder.WriteLine();
            builder.WriteLine($"{CallFactoryFor(obj.SourceGeometry)}->GetGeometry(&geoA);");
            builder.WriteLine("FFHR(_d2dFactory->CreateTransformedGeometry(geoA, transformMatrix, &transformed));");
            builder.WriteLine("geoA->Release();");
            builder.WriteLine($"result = {FieldAssignment(fieldName)}new GeoSource(transformed);");
        }

        /// <inheritdoc/>
        protected override string WriteCompositeEffectFactory(CodeBuilder builder, Mgce.CompositeEffect compositeEffect)
        {
            builder.WriteLine("ComPtr<CompositeEffect> compositeEffect(new CompositeEffect());");
            builder.WriteLine($"compositeEffect->SetMode({_s.CanvasCompositeMode(compositeEffect.Mode)});");
            foreach (var source in compositeEffect.Sources)
            {
                builder.OpenScope();
                builder.WriteLine($"auto sourceParameter = ref new CompositionEffectSourceParameter({String(source.Name)});");
                builder.WriteLine("compositeEffect->AddSource(reinterpret_cast<ABI::Windows::Graphics::Effects::IGraphicsEffectSource*>(sourceParameter));");
                builder.CloseScope();
            }

            return $"reinterpret_cast<{_s.ReferenceTypeName("Windows::Graphics::Effects::IGraphicsEffect")}>(compositeEffect.Get())";
        }

        /// <summary>
        /// Generate the body of the TryCreateAnimatedVisual() method for the composition that do not contain LoadedImageSurfaces.
        /// </summary>
        void WriteIAnimatedVisualSource(CodeBuilder builder, IAnimatedVisualSourceInfo info)
        {
            builder.WriteLine("diagnostics = nullptr;");

            // Check the runtime version and instantiate the highest compatible IAnimatedVisual class.
            WriteInstantiateHighestCompatibleAnimatedVisual(builder, info.AnimatedVisualInfos);

            builder.CloseScope();
        }

        /// <summary>
        /// Generate the body of the TryCreateAnimatedVisual() method for the composition that contains LoadedImageSurfaces.
        /// </summary>
        void WriteIDynamicAnimatedVisualSource(CodeBuilder builder, IAnimatedVisualSourceInfo info)
        {
            builder.WriteLine("m_isTryCreateAnimatedVisualCalled = true;");
            builder.WriteLine("diagnostics = nullptr;");
            builder.WriteLine();

            // Check whether the runtime will support the lowest UAP version required.
            var animatedVisualInfos = info.AnimatedVisualInfos.OrderByDescending(avi => avi.RequiredUapVersion).ToArray();
            builder.WriteLine($"if (!{animatedVisualInfos[animatedVisualInfos.Length - 1].ClassName}::IsRuntimeCompatible())");
            builder.OpenScope();
            builder.WriteLine("return nullptr;");
            builder.CloseScope();
            builder.WriteLine();
            builder.WriteLine("EnsureImageLoadingStarted();");
            builder.WriteLine();
            builder.WriteLine("if (m_isAnimatedVisualSourceDynamic && m_loadCompleteEventCount != c_loadedImageSurfaceCount)");
            builder.OpenScope();
            builder.WriteLine("return nullptr;");
            builder.CloseScope();

            // Check the runtime version and instantiate the highest compatible IAnimatedVisual class.
            WriteInstantiateHighestCompatibleAnimatedVisual(builder, animatedVisualInfos);

            builder.CloseScope();
            builder.WriteLine();

            // Generate the get() and set() methods of IsAnimatedVisualSourceDynamic property.
            WriteIsAnimatedVisualSourceDynamicGetSet(builder, info);

            // Generate the method that loads all the LoadedImageSurfaces.
            WriteEnsureImageLoadingStarted(builder, info);

            // Generate the method that handles the LoadCompleted event of the LoadedImageSurface objects.
            WriteHandleLoadCompleted(builder, info);
        }

        void WriteInstantiateHighestCompatibleAnimatedVisual(
                CodeBuilder builder,
                IReadOnlyList<IAnimatedVisualInfo> animatedVisualInfos)
        {
            foreach (var info in animatedVisualInfos.OrderByDescending(avi => avi.RequiredUapVersion))
            {
                builder.WriteLine();
                builder.WriteLine($"if ({info.ClassName}::IsRuntimeCompatible())");
                builder.OpenScope();
                builder.WriteBreakableLine($"return {_s.New(info.ClassName)}(", CommaSeparate(GetConstructorArguments(info)), ");");
                builder.CloseScope();
                builder.WriteLine();
                builder.WriteLine("return nullptr;");
            }
        }

        void WriteIsAnimatedVisualSourceDynamicGetSet(CodeBuilder builder, IAnimatedVisualSourceInfo info)
        {
            builder.WriteLine($"bool {_s.Namespace(info.Namespace)}::{info.ClassName}::IsAnimatedVisualSourceDynamic::get()");
            builder.OpenScope();
            builder.WriteLine("return m_isAnimatedVisualSourceDynamic;");
            builder.CloseScope();
            builder.WriteLine();
            builder.WriteLine($"void {_s.Namespace(info.Namespace)}::{info.ClassName}::IsAnimatedVisualSourceDynamic::set(bool isAnimatedVisualSourceDynamic)");
            builder.OpenScope();
            builder.WriteLine("if (!m_isTryCreateAnimatedVisualCalled && m_isAnimatedVisualSourceDynamic != isAnimatedVisualSourceDynamic)");
            builder.OpenScope();
            builder.WriteLine("m_isAnimatedVisualSourceDynamic = isAnimatedVisualSourceDynamic;");
            builder.WriteLine("PropertyChanged(this, ref new PropertyChangedEventArgs(\"IsAnimatedVisualSourceDynamic\"));");
            builder.CloseScope();
            builder.CloseScope();
            builder.WriteLine();
        }

        void WriteEnsureImageLoadingStarted(CodeBuilder builder, IAnimatedVisualSourceInfo info)
        {
            builder.WriteLine($"void {_s.Namespace(info.Namespace)}::{info.ClassName}::EnsureImageLoadingStarted()");
            builder.OpenScope();
            builder.WriteLine("if (!m_isImageLoadingStarted)");
            builder.OpenScope();
            builder.WriteLine($"auto eventHandler = ref new TypedEventHandler<{_s.ReferenceTypeName("LoadedImageSurface")}, {_s.ReferenceTypeName("LoadedImageSourceLoadCompletedEventArgs")}>(this, &{_s.Namespace(info.Namespace)}::{info.ClassName}::HandleLoadCompleted);");

            foreach (var n in info.LoadedImageSurfaces)
            {
                var imageMemberName = n.FieldName;
                switch (n.LoadedImageSurfaceType)
                {
                    case LoadedImageSurface.LoadedImageSurfaceType.FromStream:
                        var streamName = $"stream_{n.Name}";
                        var dataWriterName = $"dataWriter_{n.Name}";
                        builder.WriteLine($"auto {streamName} = ref new InMemoryRandomAccessStream();");
                        builder.WriteLine($"auto {dataWriterName} = ref new DataWriter({streamName}->GetOutputStreamAt(0));");
                        builder.WriteLine($"{dataWriterName}->WriteBytes({n.BytesFieldName});");
                        builder.WriteLine($"{dataWriterName}->StoreAsync();");
                        builder.WriteLine($"{dataWriterName}->FlushAsync();");
                        builder.WriteLine($"{streamName}->Seek(0);");
                        builder.WriteLine($"{imageMemberName} = Windows::UI::Xaml::Media::LoadedImageSurface::StartLoadFromStream({streamName});");
                        break;
                    case LoadedImageSurface.LoadedImageSurfaceType.FromUri:
                        builder.WriteLine($"{imageMemberName} = Windows::UI::Xaml::Media::LoadedImageSurface::StartLoadFromUri(ref new Uri(\"{n.ImageUri}\"));");
                        break;
                    default:
                        throw new InvalidOperationException();
                }

                builder.WriteLine($"{imageMemberName}->LoadCompleted += eventHandler;");
            }

            builder.WriteLine("m_isImageLoadingStarted = true;");
            builder.CloseScope();
            builder.CloseScope();
            builder.WriteLine();
        }

        void WriteHandleLoadCompleted(CodeBuilder builder, IAnimatedVisualSourceInfo info)
        {
            builder.WriteLine($"void {_s.Namespace(info.Namespace)}::{info.ClassName}::HandleLoadCompleted({_s.ReferenceTypeName("LoadedImageSurface")} sender, {_s.ReferenceTypeName("LoadedImageSourceLoadCompletedEventArgs")} e)");
            builder.OpenScope();
            builder.WriteLine("m_loadCompleteEventCount++;");
            builder.WriteLine("if (e->Status == LoadedImageSourceLoadStatus::Success)");
            builder.OpenScope();
            builder.WriteLine("if (m_isAnimatedVisualSourceDynamic && m_loadCompleteEventCount == c_loadedImageSurfaceCount)");
            builder.OpenScope();
            builder.WriteLine("RaiseAnimatedVisualInvalidatedEvent(this, nullptr);");
            builder.CloseScope();
            builder.WriteLine("m_imageSuccessfulLoadingProgress = (double)m_loadCompleteEventCount / c_loadedImageSurfaceCount;");
            builder.WriteLine("PropertyChanged(this, ref new PropertyChangedEventArgs(\"ImageSuccessfulLoadingProgress\"));");
            builder.CloseScope();
            builder.WriteLine();
            builder.WriteLine("if (m_loadCompleteEventCount == c_loadedImageSurfaceCount)");
            builder.OpenScope();
            builder.WriteLine("m_isImageLoadingCompleted = true;");
            builder.WriteLine("PropertyChanged(this, ref new PropertyChangedEventArgs(\"IsImageLoadingCompleted\"));");
            builder.CloseScope();
            builder.CloseScope();
            builder.WriteLine();
        }

        IEnumerable<string> GetConstructorArguments(IAnimatedVisualInfo info)
        {
            yield return "compositor";

            if (info.AnimatedVisualSourceInfo.IsThemed)
            {
                yield return info.AnimatedVisualSourceInfo.ThemePropertiesFieldName;
            }

            foreach (var loadedImageSurfaceNode in info.LoadedImageSurfaceNodes)
            {
                yield return loadedImageSurfaceNode.FieldName;
            }
        }

        static string[] CommaSeparate(IEnumerable<string> args)
        {
            var result = args.ToArray();
            for (var i = 0; i < result.Length - 1; i++)
            {
                result[i] += ",";
            }

            return result;
        }

        string CanvasFigureLoop(CanvasFigureLoop value) => _s.CanvasFigureLoop(value);

        static string FieldAssignment(string fieldName) => fieldName != null ? $"{fieldName} = " : string.Empty;

        string FilledRegionDetermination(CanvasFilledRegionDetermination value) => _s.FilledRegionDetermination(value);

        string Float(float value) => _s.Float(value);

        string FailFastWrapper(string value) => _s.FailFastWrapper(value);

        string String(string value) => _s.String(value);

        string Vector2(Vector2 value) => _s.Vector2(value);

        void WriteSourceDescriptionComments(CodeBuilder builder)
        {
            // Write a description of the source as comments.
            foreach (var line in GetSourceDescriptionLines())
            {
                builder.WriteComment(line);
            }
        }

        void WriteHeaderNamespaceStart(CodeBuilder builder, IAnimatedVisualSourceInfo info, string inherits)
        {
            if (info.IsThemed)
            {
                // TODO - disabling for now while we figure out how to turn this on and off.
                //builder.WriteLine("#include \"IThemedAnimatedVisualSource.h\"");
            }

            builder.WriteLine();
            builder.WriteLine($"namespace {_s.Namespace(info.Namespace)}");
            builder.OpenScope();

            WriteSourceDescriptionComments(builder);

            if (info.IsThemed)
            {
                // Make the AnimatedVisualSource inherit from IThemedAnimatedVisualSource.
                // TODO - disabling for now while we figure out how to turn this on and off.
                //inherits += ", IThemedAnimatedVisualSource";
            }

            if (_isCppWinrtMode)
            {
                builder.WriteLine($"class {info.ClassName}");
                builder.Indent();
                builder.WriteLine($": public winrt::implements<{info.ClassName}, winrt::{inherits}>");
                builder.UnIndent();
            }
            else
            {
                builder.WriteLine($"public ref class {info.ClassName} sealed");
                builder.Indent();
                builder.WriteLine($": public {inherits}");
                builder.UnIndent();
            }

            builder.OpenScope();

            var wuc =
                _isCppWinrtMode
                    ? $"winrt::{Wuc}"
                    : Wuc;

            if (info.IsThemed)
            {
                // Add a field to hold the theme property set.
                builder.WriteLine($"{wuc}::{_typeName.CompositionPropertySet} {info.ThemePropertiesFieldName}{{ nullptr }};");

                // Add fields for each of the theme properties.
                foreach (var prop in info.SourceMetadata.PropertyBindings)
                {
                    var exposedTypeName = QualifiedTypeName(prop.exposedType);

                    var initialValue = prop.exposedType switch
                    {
                        PropertySetValueType.Color => _s.ColorArgs((WinCompData.Wui.Color)prop.initialValue),
                        PropertySetValueType.Scalar => _s.Float((float)prop.initialValue),
                        PropertySetValueType.Vector2 => _s.Vector2Args((Vector2)prop.initialValue),
                        PropertySetValueType.Vector3 => _s.Vector3Args((Vector3)prop.initialValue),
                        PropertySetValueType.Vector4 => _s.Vector4Args((Vector4)prop.initialValue),
                        _ => throw new InvalidOperationException(),
                    };

                    WriteInitializedField(builder, exposedTypeName, $"_theme{prop.bindingName}", _s.VariableInitialization(initialValue));
                }

                builder.WriteLine();
                builder.WriteLine($"{wuc}::{_typeName.CompositionPropertySet} EnsureThemeProperties({wuc}::{_typeName.Compositor} compositor);");
                builder.WriteLine();
            }

            builder.UnIndent();
            builder.WriteLine("public:");
            builder.Indent();
            if (info.IsThemed)
            {
                // Write properties declarations for each themed property.
                foreach (var prop in info.SourceMetadata.PropertyBindings)
                {
                    if (_isCppWinrtMode)
                    {
                        builder.WriteLine($"{QualifiedTypeName(prop.exposedType)} {prop.bindingName}();");
                        builder.WriteLine($"void {prop.bindingName}({QualifiedTypeName(prop.exposedType)} value);");
                    }
                    else
                    {
                        builder.WriteLine($"property {QualifiedTypeName(prop.exposedType)} {prop.bindingName}");
                        builder.OpenScope();
                        builder.WriteLine($"{QualifiedTypeName(prop.exposedType)} get();");
                        builder.WriteLine($"void set ({QualifiedTypeName(prop.exposedType)} value);");
                        builder.CloseScope();
                        builder.WriteLine();
                    }
                }

                // TODO - if IThemedAnimatedVisualSource is enabled then this becomes virtual, otherwise not.
                //builder.WriteLine($"virtual {wuc}::{_typeName.CompositionPropertySet} GetThemeProperties({wuc}::{_typeName.Compositor} compositor);");
                builder.WriteLine($"{wuc}::{_typeName.CompositionPropertySet} GetThemeProperties({wuc}::{_typeName.Compositor} compositor);");
                builder.WriteLine();
            }
        }

        void WriteIAnimatedVisualSourceHeaderText(CodeBuilder builder, IAnimatedVisualSourceInfo info)
        {
            WriteHeaderNamespaceStart(builder, info, $"{Muxc}::IAnimatedVisualSource");
            var returnType =
                _isCppWinrtMode
                    ? $"winrt::{Muxc}::{_typeName.IAnimatedVisual}"
                    : $"{Muxc}::{_typeName.IAnimatedVisual}";

            builder.WriteLine($"virtual {returnType} TryCreateAnimatedVisual(");
            builder.Indent();
            if (_isCppWinrtMode)
            {
                builder.WriteLine($"const winrt::{Wuc}::{_typeName.Compositor}& compositor,");
                builder.WriteLine($"winrt::{_typeName.Object}& diagnostics);");
            }
            else
            {
                builder.WriteLine($"{Wuc}::{_typeName.Compositor} compositor,");
                builder.WriteLine($"{_typeName.Object}* diagnostics);");
            }

            builder.UnIndent();
            builder.CloseCppTypeScope();
            builder.CloseScope();
        }

        void WriteIDynamicAnimatedVisualSourceHeaderText(CodeBuilder builder, IAnimatedVisualSourceInfo info)
        {
            var loadedImageSurfaceNodes = info.LoadedImageSurfaces.ToArray();

            builder.WriteLine($"using namespace {Muxc};");
            builder.WriteLine("using namespace Platform;");
            builder.WriteLine("using namespace Windows::UI::Xaml;");
            builder.WriteLine("using namespace Windows::UI::Xaml::Data;");
            builder.WriteLine("using namespace Windows::UI::Xaml::Media;");

            WriteHeaderNamespaceStart(builder, info, "public IDynamicAnimatedVisualSource, INotifyPropertyChanged");

            builder.WriteLine();
            builder.WriteLine($"virtual event {_s.ReferenceTypeName($"Windows::Foundation::TypedEventHandler<{_s.ReferenceTypeName("IDynamicAnimatedVisualSource")}, {_typeName.Object}>")} AnimatedVisualInvalidated");
            builder.OpenScope();
            builder.WriteLine($"Windows::Foundation::EventRegistrationToken add({_s.ReferenceTypeName($"Windows::Foundation::TypedEventHandler<{_s.ReferenceTypeName("IDynamicAnimatedVisualSource")}, {_typeName.Object}>")} value)");
            builder.OpenScope();
            builder.WriteLine("return m_InternalHandler::add(value);");
            builder.CloseScope();
            builder.WriteLine("void remove(Windows::Foundation::EventRegistrationToken token)");
            builder.OpenScope();
            builder.WriteLine("m_InternalHandler::remove(token);");
            builder.CloseScope();
            builder.CloseScope();

            builder.WriteLine();
            builder.WriteLine($"virtual {_s.ReferenceTypeName($"{Muxc}::{_typeName.IAnimatedVisual}")} TryCreateAnimatedVisual(");
            builder.Indent();
            builder.WriteLine($"{Wuc}::{_typeName.Compositor} compositor,");
            builder.WriteLine($"{_typeName.Object}* diagnostics);");
            builder.UnIndent();
            builder.WriteLine();
            builder.WriteLine($"virtual event {_s.ReferenceTypeName("PropertyChangedEventHandler")} PropertyChanged;");
            builder.WriteSummaryComment("If this property is set to true, <see cref=\"TryCreateAnimatedVisual\"/> will" +
                " return null until all images have loaded. When all images have loaded, <see cref=\"TryCreateAnimatedVisual\"/>" +
                " will return the AnimatedVisual. To use, set it when declaring the AnimatedVisualSource. Once" +
                " <see cref=\"TryCreateAnimatedVisual\"/> is called, changes made to this property will be ignored." +
                " Default value is true.");
            builder.WriteLine("property bool IsAnimatedVisualSourceDynamic");
            builder.OpenScope();
            builder.WriteLine("bool get();");
            builder.WriteLine("void set(bool value);");
            builder.CloseScope();
            builder.WriteSummaryComment("Returns true if all images have loaded. To see if the images succeeded to load," +
                " see <see cref=\"ImageSuccessfulLoadingProgress\"/>.");
            builder.WriteLine("property bool IsImageLoadingCompleted");
            builder.OpenScope();
            builder.WriteLine("bool get() { return m_isImageLoadingCompleted; }");
            builder.CloseScope();

            builder.WriteSummaryComment("Represents the progress of successful image loading. Returns a value between" +
                " 0 and 1. 0 means none of the images succeeded to load. 1 means all images succeeded to load.");
            builder.WriteLine("property double ImageSuccessfulLoadingProgress");
            builder.OpenScope();
            builder.WriteLine("double get() { return m_imageSuccessfulLoadingProgress; }");
            builder.CloseScope();

            builder.UnIndent();
            builder.WriteLine("private:");
            builder.Indent();
            builder.WriteLine($"const int c_loadedImageSurfaceCount = {info.LoadedImageSurfaces.Distinct().Count()};");
            builder.WriteLine("double m_imageSuccessfulLoadingProgress{};");
            builder.WriteLine("int m_loadCompleteEventCount{};");
            builder.WriteLine("bool m_isAnimatedVisualSourceDynamic{true};");
            builder.WriteLine("bool m_isImageLoadingCompleted{}");
            builder.WriteLine("bool m_isTryCreateAnimatedVisualCalled{}");
            builder.WriteLine("bool m_isImageLoadingStarted{}");
            builder.WriteLine($"event {_s.ReferenceTypeName($"Windows::Foundation::TypedEventHandler<{_s.ReferenceTypeName("IDynamicAnimatedVisualSource")}, {_typeName.Object}>")} m_InternalHandler;");

            foreach (var n in loadedImageSurfaceNodes)
            {
                builder.WriteLine($"{_s.ReferenceTypeName(n.TypeName)} {n.FieldName}{{}};");
            }

            builder.WriteLine("void EnsureImageLoadingStarted();");
            builder.WriteLine($"void HandleLoadCompleted({_s.ReferenceTypeName("LoadedImageSurface")} sender, {_s.ReferenceTypeName("LoadedImageSourceLoadCompletedEventArgs")} e);");
            builder.WriteLine($"void RaiseAnimatedVisualInvalidatedEvent({_s.ReferenceTypeName("IDynamicAnimatedVisualSource")} sender, {_typeName.Object} object)");
            builder.OpenScope();
            builder.OpenScope();
            builder.WriteLine("m_InternalHandler::raise(sender, object);");
            builder.CloseScope();
            builder.CloseScope();
            builder.CloseScope();
            builder.CloseCppTypeScope();
            builder.CloseScope();
        }

        string CompositionEffectClass =>
@"

enum CanvasComposite : int
{
    SourceOver = 0,
    DestinationOver = 1,
    SourceIn = 2,
    DestinationIn = 3,
    SourceOut = 4,
    DestinationOut = 5,
    SourceAtop = 6,
    DestinationAtop = 7,
    Xor = 8,
    Add = 9,
    Copy = 10,
    BoundedCopy = 11,
    MaskInvert = 12,
};

// This class is a substitute for the Microsoft::Graphics::Canvas::Effects::CompositeEffect
// class so that composite effects can be used with 
// Windows::UI::Composition::CompositionEffectBrush without requiring Win2d. This is
// achieved by implementing the interfaces Windows::UI::Composition requires for it
// to consume an effect.
class CompositeEffect final :
    public ABI::Windows::Graphics::Effects::IGraphicsEffect,
    public ABI::Windows::Graphics::Effects::IGraphicsEffectSource,
    public ABI::Windows::Graphics::Effects::IGraphicsEffectD2D1Interop
{
public:
    void SetMode(CanvasComposite mode) { m_mode = mode; }

    void AddSource(IGraphicsEffectSource* source)
    {
        m_sources.emplace_back(Microsoft::WRL::ComPtr<IGraphicsEffectSource>(source));
    }

    // IGraphicsEffect
    IFACEMETHODIMP get_Name(HSTRING* name) override { return m_name.CopyTo(name); }

    IFACEMETHODIMP put_Name(HSTRING name) override { return m_name.Set(name); }

    // IGraphicsEffectD2D1Interop
    IFACEMETHODIMP GetEffectId(GUID* id) override 
    { 
        if (id != nullptr)
        {
            // set CLSID_D2D1Composite value
            *id = { 0x48fc9f51, 0xf6ac, 0x48f1, { 0x8b, 0x58,  0x3b,  0x28,  0xac,  0x46,  0xf7,  0x6d } };
        }

        return S_OK; 
    }

    IFACEMETHODIMP GetSourceCount(UINT* count) override
    {
        if (count != nullptr)
        {
            *count = static_cast<UINT>(m_sources.size());
        }

        return S_OK;
    }

    IFACEMETHODIMP GetSource(
        UINT index, 
        IGraphicsEffectSource** source) override
    {
        if (index >= m_sources.size() ||
            source == nullptr)
        {
            return E_INVALIDARG;
        }

        *source = m_sources.at(index).Get();
        (*source)->AddRef();

        return S_OK;
    }

    IFACEMETHODIMP GetPropertyCount(UINT * count) override { *count = 1; return S_OK; }

    IFACEMETHODIMP GetProperty(
        UINT index, 
        ABI::Windows::Foundation::IPropertyValue ** value) override
    {
        Microsoft::WRL::ComPtr<ABI::Windows::Foundation::IPropertyValueStatics> propertyValueFactory;
        Microsoft::WRL::Wrappers::HStringReference activatableClassId{ RuntimeClass_Windows_Foundation_PropertyValue };
        HRESULT hr = ABI::Windows::Foundation::GetActivationFactory(activatableClassId.Get(), &propertyValueFactory);

        if (SUCCEEDED(hr))
        {
            switch (index)
            {
                case D2D1_COMPOSITE_PROP_MODE: 
                    return propertyValueFactory->CreateUInt32(m_mode, (IInspectable**)value);
                default: 
                    return E_INVALIDARG;
            }
        }

        return hr;
    }

    IFACEMETHODIMP GetNamedPropertyMapping(
        LPCWSTR, 
        UINT*,
        ABI::Windows::Graphics::Effects::GRAPHICS_EFFECT_PROPERTY_MAPPING*) override
    {
        return E_INVALIDARG;
    }

    // IUnknown
    IFACEMETHODIMP QueryInterface(
        REFIID iid,
        void ** ppvObject) override
    {
        if (ppvObject != nullptr)
        {
            *ppvObject = nullptr;

            if (iid == __uuidof(IUnknown))
            {
                *ppvObject = static_cast<IUnknown*>(static_cast<IGraphicsEffect*>(this));
            }
            else if (iid == __uuidof(IInspectable))
            {
                *ppvObject = static_cast<IInspectable*>(static_cast<IGraphicsEffect*>(this));
            }
            else if (iid == __uuidof(IGraphicsEffect))
            {
                *ppvObject = static_cast<IGraphicsEffect*>(this);
            }
            else if (iid == __uuidof(IGraphicsEffectSource))
            {
                *ppvObject = static_cast<IGraphicsEffectSource*>(this);
            }
            else if (iid == __uuidof(IGraphicsEffectD2D1Interop))
            {
                *ppvObject = static_cast<IGraphicsEffectD2D1Interop*>(this);
            }

            if (*ppvObject != nullptr)
            {
                AddRef();
                return S_OK;
            }
        }

        return E_NOINTERFACE;
    }

    IFACEMETHODIMP_(ULONG) AddRef() override
    {
        return InterlockedIncrement(&m_cRef);
    }

    IFACEMETHODIMP_(ULONG) Release() override
    {
        ULONG cRef = InterlockedDecrement(&m_cRef);
        if (0 == cRef)
        {
            delete this;
        }

        return cRef;
    }

    // IInspectable
    IFACEMETHODIMP GetIids(
        ULONG * iidCount,
        IID ** iids) override
    {
        if (iidCount != nullptr)
        {
            *iidCount = 0;
        }

        if (iids != nullptr)
        {
            *iids = nullptr;
        }

        return E_NOTIMPL;
    }

    IFACEMETHODIMP GetRuntimeClassName(
        HSTRING * /*runtimeName*/) override
    {
        return E_NOTIMPL;
    }

    IFACEMETHODIMP GetTrustLevel(
        TrustLevel* trustLvl) override
    {
        if (trustLvl != nullptr)
        {
            *trustLvl = BaseTrust;
        }

        return S_OK;
    }

private:
    ULONG m_cRef = 0;

    CanvasComposite m_mode{};

    Microsoft::WRL::Wrappers::HString m_name{};

    std::vector<Microsoft::WRL::ComPtr<IGraphicsEffectSource>> m_sources;
};
";

        static string QualifiedTypeName(PropertySetValueType propertySetValueType)
            => propertySetValueType switch
            {
                PropertySetValueType.Color => "Windows::UI::Color",
                _ => TypeName(propertySetValueType),
            };

        static string TypeName(PropertySetValueType propertySetValueType)
            => propertySetValueType switch
            {
                PropertySetValueType.Color => "Color",
                PropertySetValueType.Scalar => "float",
                PropertySetValueType.Vector2 => "float2",
                PropertySetValueType.Vector3 => "float3",
                PropertySetValueType.Vector4 => "float4",
                _ => throw new InvalidOperationException()
            };

        readonly struct TypeNames
        {
            internal TypeNames(Stringifier stringifier, bool isCppWinrtMode)
            {
                CompositionPropertySet = stringifier.ReferenceTypeName(nameof(CompositionPropertySet));
                Compositor = stringifier.ReferenceTypeName(nameof(Compositor));
                Object = isCppWinrtMode ? stringifier.ReferenceTypeName("IInspectable") : stringifier.ReferenceTypeName("Object");
                Visual = stringifier.ReferenceTypeName(nameof(Visual));
                IAnimatedVisual = stringifier.ReferenceTypeName("IAnimatedVisual");
                IGeometrySource2D = "IGeometrySource2D";
            }

            internal string CompositionPropertySet { get; }

            internal string Compositor { get; }

            internal string IAnimatedVisual { get; }

            internal string IGeometrySource2D { get; }

            internal string Object { get; }

            internal string Visual { get; }
        }
    }
}
